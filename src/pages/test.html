<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    // var islandPerimeter = function (grid) {
    //   let hengl = 0
    //   let shul = 0
    //   let ss = []
    //   let num = 0
    //   for (let i = 0; i < grid.length; i++) {
    //     let j = 0
    //     let sum = 0
    //     let flag = true
    //     for (let j = 0; j < grid[i].length; j++) {
    //       if (!ss[j]) ss[j] = []
    //       ss[j][i] = grid[i][j]
    //       // if (grid[i][j] === 1) {
    //       //   num++
    //       // }
    //       if (grid[i][j] === 1 && flag) {
    //         sum++
    //         num++
    //       }
    //       if (grid[i][j] === 0 && sum !== 0) {
    //         flag = false
    //       }
    //     }
    //     if (sum !== 0) {
    //       hengl = hengl + (sum - 1)
    //     }


    //   }


    //   for (let i = 0; i < ss.length; i++) {
    //     let j = 0
    //     let sum = 0
    //     let flag = true
    //     for (let j = 0; j < ss[i].length; j++) {

    //       if (ss[i][j] === 1 && flag) {
    //         sum++
    //       }
    //       if (ss[i][j] === 0 && sum !== 0) {
    //         flag = false
    //         break
    //       }
    //     }
    //     if (sum === 0) break
    //     shul = shul + (sum - 1)
    //   }
    //   return { shul, hengl, ss, num, grid }
    // };


    // console.log(islandPerimeter([[1, 1, 1, 0, 0, 1], [1, 1, 1, 0], [0, 1, 0, 0], [1, 0, 0, 0]]))

    // var insert = function (intervals, newInterval) {
    //   let result = []
    //   const l = intervals.length
    //   const [item1, item2] = newInterval
    //   const [start1, start2] = intervals[0]
    //   const [end1, end2] = intervals[l - 1]
    //   if (item2 < start1) return [newInterval, ...intervals]
    //   if (item1 > end2) return [...intervals, newInterval]

    //   let min = -1; max = -1
    //   for (let i = 0; i < l; i++) {
    //     const [first, last] = intervals[i]
    //     if ((min + 1) && (max + 1)) break
    //     if (item1 < first && !(min + 1)) {
    //       min = i
    //     }
    //     if (item2 <= last && !(max + 1)) {
    //       max = i
    //     }
    //   }
    //   const minarr = intervals.slice(min)
    //   const maxarr = intervals.slice(max)

    //   const minarrFirst = intervals.slice(0, min)
    //   if (min === -1) {
    //     console.log(max, intervals[max])
    //     return [[item1, intervals[max][1]], ...maxarr]
    //   }

    //   if (max === -1) {
    //     console.log(intervals, newInterval, minarrFirst, min, max)
    //     return [...minarrFirst, [intervals[min][0], item2]]
    //   }

    //   if (min + 1 && max + 1) {
    //     if (min === max) return intervals
    //     else {
    //       console.log(intervals, newInterval, min, max, minarrFirst)
    //       return [...minarrFirst, [intervals[min][0], item2], ...maxarr]
    //     }
    //   }


    // };


    // console.log(insert([[1, 2], [3, 5], [6, 7], [8, 10], [12, 16]],
    //   [4, 8]))


    // 根据数字二进制下 1 的数目排序
    // var sortByBits = function (arr) {
    //   const result = arr.map(item => getOneNum(item))
    //   return result
    // };

    // function getOneNum(n) {
    //   let nums = 0;

    //   do {
    //     if (n & 1) {
    //       nums++
    //     }
    //     // n=n<<1
    //   } while (n = n >> 1)

    //   return nums
    // }

    // console.log(sortByBits([0, 1, 2, 3, 4, 5, 6, 7, 8]))

    // var findRotateSteps = function (ring, key) {
    //   let pring = {}

    //   let first = pring
    //   let last = null
    //   let l = ring.length
    //   for (let i = 0; i < ring.length; i++) {
    //     pring.val = ring[i]
    //     pring.last = last
    //     pring.next = {}
    //     last = pring
    //     pring = pring.next
    //   }
    //   pring = first
    //   first.last = pring;
    //   pring = first
    //   let ptr = pring
    //   let result = 0
    //   key = key.split('')
    //   console.log(pring, 'lll')
    //   const getTimes = (charcode) => {
    //     let leftn = 0;
    //     let rightn = 0;
    //     let leftObj, rightObj
    //     while (leftn < l) {
    //       if (ptr.val === charcode) break;
    //       leftn++;
    //       ptr = ptr.next
    //     }
    //     leftObj = ptr
    //     ptr = pring
    //     while (rightn < l) {
    //       if (ptr.val === charcode) break;
    //       rightn++;
    //       ptr = ptr.last
    //     }
    //     rightObj = ptr
    //     ptr = pring = leftn < rightn ? leftObj : rightObj
    //     console.log(leftn, rightn)
    //     return leftn < rightn ? leftn + 1 : rightn + 1
    //   }
    //   key.forEach(item => {
    //     // console.log(getTimes(item))
    //     result = result + getTimes(item)
    //   })


    //   return result
    // };

    // console.log(findRotateSteps("abcde",
    //   "ade"))

    //     给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。

    // 对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。


    // var sortArrayByParityII = function(A) {
    //     const l = A.length
    //     // let a = 0,b=0;
    //     let a = A.filter(item=>!(item&1))
    //     let b = A.filter(item=>(item&1))
    //     let result = []
    //     for(let i=0;i<l;i++){
    //         const s = Math.floor(i/2)

    //         if(i&1){
    //             result[i] = b[s]
    //         }else {
    //             result[i] = a[s]
    //         }
    //     }
    //     return result
    // };

    // console.log(sortArrayByParityII([4,1,1,0,1,0]))
    // 假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。

    // var reconstructQueue = function(people) {
    //     let result = []
    //     const l = people.length
    //     var getTrue=(peopleItem)=>{
    //         let num = 0
    //         for(let i=0;i<result.length;i++){
    //             if(result[i]>=peopleItem[0]){
    //                 num++
    //             }
    //             if(num===peopleItem[1]){
    //                 result.splice(i,0,[...peopleItem])
    //                 return false
    //             }
    //         }
    //         return true
    //     }
    //     for(let i=0;i<l;i++){

    //         if(getTrue(people[i])){
    //             result.push([...people[i]])
    //         }
    //     }
    //     return result

    // };

    // console.log(reconstructQueue([[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]))

    // 实现instance of 方法
    // var obj = new Fun()
    // function Fun1(){
    //   this.constructor = Fun
    // }
    // function Fun(){
    //   // this.constructor = 'Fun'
    // }
    // // Fun.prototype.constructor = {jjjj:'kk'}
    // function instance(obj,type){
    //   const obj1 = new type()
    //   // return obj1.__proto__===obj.__proto__

    //   return {my:obj1.__proto__===obj.__proto__,instance:obj instanceof type}
    // }
    // console.log(instance(obj,Fun))


    // 在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。

    // 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。

    // 如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。


    var canCompleteCircuit = function (gas, cost) {
      // let yu = gas.map((item,index)=>item-cost[index])
      let l = gas.length
      let yu = 0
      let i = 0, first = 0
      let ci = 0
      while (ci < l && first < l) {

        if (i === l) {
          i = 0
        }
        yu = yu + (gas[i] - cost[i])
        if (yu < 0) {
          first = i + 1;

        }
        if (ci === l - 1) {
          return first
        }
        ci++
        i++
      }
      return first + 1

    };

    console.log(canCompleteCircuit([1, 2, 3, 4, 5],
      [3, 4, 5, 1, 2]))
  </script>
</body>

</html>