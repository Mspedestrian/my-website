<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    // var islandPerimeter = function (grid) {
    //   let hengl = 0
    //   let shul = 0
    //   let ss = []
    //   let num = 0
    //   for (let i = 0; i < grid.length; i++) {
    //     let j = 0
    //     let sum = 0
    //     let flag = true
    //     for (let j = 0; j < grid[i].length; j++) {
    //       if (!ss[j]) ss[j] = []
    //       ss[j][i] = grid[i][j]
    //       // if (grid[i][j] === 1) {
    //       //   num++
    //       // }
    //       if (grid[i][j] === 1 && flag) {
    //         sum++
    //         num++
    //       }
    //       if (grid[i][j] === 0 && sum !== 0) {
    //         flag = false
    //       }
    //     }
    //     if (sum !== 0) {
    //       hengl = hengl + (sum - 1)
    //     }


    //   }


    //   for (let i = 0; i < ss.length; i++) {
    //     let j = 0
    //     let sum = 0
    //     let flag = true
    //     for (let j = 0; j < ss[i].length; j++) {

    //       if (ss[i][j] === 1 && flag) {
    //         sum++
    //       }
    //       if (ss[i][j] === 0 && sum !== 0) {
    //         flag = false
    //         break
    //       }
    //     }
    //     if (sum === 0) break
    //     shul = shul + (sum - 1)
    //   }
    //   return { shul, hengl, ss, num, grid }
    // };


    // console.log(islandPerimeter([[1, 1, 1, 0, 0, 1], [1, 1, 1, 0], [0, 1, 0, 0], [1, 0, 0, 0]]))

    // var insert = function (intervals, newInterval) {
    //   let result = []
    //   const l = intervals.length
    //   const [item1, item2] = newInterval
    //   const [start1, start2] = intervals[0]
    //   const [end1, end2] = intervals[l - 1]
    //   if (item2 < start1) return [newInterval, ...intervals]
    //   if (item1 > end2) return [...intervals, newInterval]

    //   let min = -1; max = -1
    //   for (let i = 0; i < l; i++) {
    //     const [first, last] = intervals[i]
    //     if ((min + 1) && (max + 1)) break
    //     if (item1 < first && !(min + 1)) {
    //       min = i
    //     }
    //     if (item2 <= last && !(max + 1)) {
    //       max = i
    //     }
    //   }
    //   const minarr = intervals.slice(min)
    //   const maxarr = intervals.slice(max)

    //   const minarrFirst = intervals.slice(0, min)
    //   if (min === -1) {
    //     console.log(max, intervals[max])
    //     return [[item1, intervals[max][1]], ...maxarr]
    //   }

    //   if (max === -1) {
    //     console.log(intervals, newInterval, minarrFirst, min, max)
    //     return [...minarrFirst, [intervals[min][0], item2]]
    //   }

    //   if (min + 1 && max + 1) {
    //     if (min === max) return intervals
    //     else {
    //       console.log(intervals, newInterval, min, max, minarrFirst)
    //       return [...minarrFirst, [intervals[min][0], item2], ...maxarr]
    //     }
    //   }


    // };


    // console.log(insert([[1, 2], [3, 5], [6, 7], [8, 10], [12, 16]],
    //   [4, 8]))


    // 根据数字二进制下 1 的数目排序
    // var sortByBits = function (arr) {
    //   const result = arr.map(item => getOneNum(item))
    //   return result
    // };

    // function getOneNum(n) {
    //   let nums = 0;

    //   do {
    //     if (n & 1) {
    //       nums++
    //     }
    //     // n=n<<1
    //   } while (n = n >> 1)

    //   return nums
    // }

    // console.log(sortByBits([0, 1, 2, 3, 4, 5, 6, 7, 8]))

    // var findRotateSteps = function (ring, key) {
    //   let pring = {}

    //   let first = pring
    //   let last = null
    //   let l = ring.length
    //   for (let i = 0; i < ring.length; i++) {
    //     pring.val = ring[i]
    //     pring.last = last
    //     pring.next = {}
    //     last = pring
    //     pring = pring.next
    //   }
    //   pring = first
    //   first.last = pring;
    //   pring = first
    //   let ptr = pring
    //   let result = 0
    //   key = key.split('')
    //   console.log(pring, 'lll')
    //   const getTimes = (charcode) => {
    //     let leftn = 0;
    //     let rightn = 0;
    //     let leftObj, rightObj
    //     while (leftn < l) {
    //       if (ptr.val === charcode) break;
    //       leftn++;
    //       ptr = ptr.next
    //     }
    //     leftObj = ptr
    //     ptr = pring
    //     while (rightn < l) {
    //       if (ptr.val === charcode) break;
    //       rightn++;
    //       ptr = ptr.last
    //     }
    //     rightObj = ptr
    //     ptr = pring = leftn < rightn ? leftObj : rightObj
    //     console.log(leftn, rightn)
    //     return leftn < rightn ? leftn + 1 : rightn + 1
    //   }
    //   key.forEach(item => {
    //     // console.log(getTimes(item))
    //     result = result + getTimes(item)
    //   })


    //   return result
    // };

    // console.log(findRotateSteps("abcde",
    //   "ade"))

    //     给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。

    // 对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。


    // var sortArrayByParityII = function(A) {
    //     const l = A.length
    //     // let a = 0,b=0;
    //     let a = A.filter(item=>!(item&1))
    //     let b = A.filter(item=>(item&1))
    //     let result = []
    //     for(let i=0;i<l;i++){
    //         const s = Math.floor(i/2)

    //         if(i&1){
    //             result[i] = b[s]
    //         }else {
    //             result[i] = a[s]
    //         }
    //     }
    //     return result
    // };

    // console.log(sortArrayByParityII([4,1,1,0,1,0]))
    // 假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。

    // var reconstructQueue = function(people) {
    //     let result = []
    //     const l = people.length
    //     var getTrue=(peopleItem)=>{
    //         let num = 0
    //         for(let i=0;i<result.length;i++){
    //             if(result[i]>=peopleItem[0]){
    //                 num++
    //             }
    //             if(num===peopleItem[1]){
    //                 result.splice(i,0,[...peopleItem])
    //                 return false
    //             }
    //         }
    //         return true
    //     }
    //     for(let i=0;i<l;i++){

    //         if(getTrue(people[i])){
    //             result.push([...people[i]])
    //         }
    //     }
    //     return result

    // };

    // console.log(reconstructQueue([[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]))

    // 实现instance of 方法
    // var obj = new Fun()
    // function Fun1(){
    //   this.constructor = Fun
    // }
    // function Fun(){
    //   // this.constructor = 'Fun'
    // }
    // // Fun.prototype.constructor = {jjjj:'kk'}
    // function instance(obj,type){
    //   const obj1 = new type()
    //   // return obj1.__proto__===obj.__proto__

    //   return {my:obj1.__proto__===obj.__proto__,instance:obj instanceof type}
    // }
    // console.log(instance(obj,Fun))


    // 在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。

    // 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。

    // 如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。


    // var canCompleteCircuit = function (gas, cost) {
    //   // let yu = gas.map((item,index)=>item-cost[index])
    //   let l = gas.length
    //   let yu = 0
    //   let i = 0, first = 0
    //   let ci = 0
    //   while (ci < l && first < l) {

    //     if (i === l) {
    //       i = 0
    //     }
    //     yu = yu + (gas[i] - cost[i])
    //     if (yu < 0) {
    //       first = i + 1;

    //     }
    //     if (ci === l - 1) {
    //       return first
    //     }
    //     ci++
    //     i++
    //   }
    //   return first + 1

    // };

    // console.log(canCompleteCircuit([1, 2, 3, 4, 5],
    //   [3, 4, 5, 1, 2]))

    //     给出一个完全二叉树，求出该树的节点个数。

    // 说明：

    // 完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。


    // var countNodes = function (root) {
    //   let ptr = root;
    //   let n = 1;
    //   let left = []
    //   let right = []
    //   let arr = [root]
    //   let last = []
    //   while (true) {

    //     let last = []
    //     for (let i = 0; i < arr.length; i++) {
    //       if (arr[i].left && arr[i].right) {
    //         last.push(arr[i].left)
    //         last.push(arr[i].right);

    //       } else if (root.left) {
    //         return n + (i + 1) * 2 - 1

    //       } else {
    //         return n + (i + 1) * 2 - 2
    //       }

    //     }
    //     arr = last
    //     n = n * 2 + 1

    //   }

    // };
    // console.log(countNodes({
    //   val: 1,
    //   left: {
    //     val: 2,
    //     left: {
    //       val: 4
    //     },
    //     right: {
    //       val: 5
    //     }
    //   },
    //   right: {
    //     val: 3,
    //     left: {
    //       val: 7
    //     },
    //     right: {
    //       val: 8
    //     }
    //   }
    // }))
    // var fourSumCount = function (A, B, C, D) {
    //   const l = al = bl = cl = dl = A.length;
    //   let ss = []
    //   let result = 0
    //   let a = 0, b = 0, c = 0, d = 0;
    //   A.sort((a, b) => a - b)
    //   B.sort((a, b) => a - b)
    //   C.sort((a, b) => a - b)
    //   D.sort((a, b) => a - b)
    //   let mind = D[0], maxd = D[l - 1], mina = A[0], maxa = A[l - 1], minb = B[0], maxb = B[l - 1], minc = C[0], maxc = C[l - 1]
    //   minbcd = B[0] + C[0] + D[0]
    //   maxbcd = B[l - 1] + C[l - 1] + D[l - 1]

    //   mincd = C[0] + D[0], maxcd = C[l - 1] + D[l - 1]
    //   // while(a<l&&b<l&&c<l&&d<l){
    //   //     const sa = A[a],sb = B[b],sc = C[c],sd = D[d]
    //   //     let yu = 0-sa-sb-sc
    //   //     if(yu<min||yu>max){
    //   //         break
    //   //     }
    //   //     if(sa<minbcd||sa>maxbcd){
    //   //         break
    //   //     }

    //   // }
    //   let arr = []
    //   // let mind = D[0],maxd = D[l-1],mina = A[0],maxa = A[l-1],minb = B[0],maxb = B[l-1],minc = C[0],maxc = C[l-1]
    //   for (let a = 0; a < al; a++) {
    //     let res = A[a]
    //     if (res + maxbcd < 0) {
    //       res = res - A[a]
    //       continue
    //     }
    //     if (res + minbcd > 0) {
    //       return result
    //     }
    //     for (let b = 0; b < bl; b++) {
    //       res = res + B[b]
    //       if (res + maxcd < 0) {
    //         res = res - B[b]
    //         continue
    //       }
    //       if (res + mincd > 0) {
    //         return result
    //       }
    //       for (let c = 0; c < cl; c++) {
    //         res = res + C[c]
    //         if (res + maxd < 0) {
    //           res = res - C[c]
    //           continue
    //         }
    //         if (res + mind > 0) {
    //           return result
    //         }
    //         for (let d = 0; d < dl; d++) {
    //           res = res + D[d]
    //           if (res === 0) {
    //             result++
    //             arr.push([a, b, c, d])
    //           }
    //         }
    //       }
    //     }
    //   }
    //   console.log(arr)
    //   return result

    // };
    // console.log(fourSumCount([-1, -1],
    //   [-1, 1],
    //   [-1, 1],
    //   [1, -1]))



    //     给定一个字符串S，检查是否能重新排布其中的字母，使得两相邻的字符不同。

    // 若可行，输出任意可行的结果。若不可行，返回空字符串。
    // 字符串不可以通过这样赋值？？
    var reorganizeString = function (S) {
      S = S.split('')
      let map = {}
      for (let i = 0; i < S.length; i++) {
        let ss = map[S[i]] || 0
        map[S[i]] = ss + 1
      }
      let result = []
      let isFlag = true
      while (isFlag) {
        var arr = Object.keys(map)
        const noZeroArr = arr.filter((code) => map[code] > 0)
        // console.log(noZeroArr)
        if (noZeroArr.length === 0) { isFlag = false; break }
        if (noZeroArr.length === 1) {
          const code = noZeroArr[0]
          if (code !== result[0]) {
            result.unshift(code)
          }
          else if (code !== result.slice(-1)[0]) {
            result.push(code)
          }
          else {
            const codeindex = result.findIndex((item, index) => {
              return code !== item && code !== result[index + 1]
            })
            if (codeindex == -1) {
              isFlag = false;
              result = []
              break
            }
            result.splice(codeindex + 1, 0, code)
          }
          map[code]--
          continue
        }
        noZeroArr.forEach(code => {
          if (map[code] > 0) {
            result.push(code)
            map[code]--
          }
        })
      }


      console.log(result)
      return result.join('')

    };
    console.log(reorganizeString("vvlov"))
  </script>
</body>

</html>